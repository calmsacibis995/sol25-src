/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 *
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 *
 *
 *
 * 		Copyright Notice
 *
 * Notice of copyright on this source code product does not indicate
 * publication.
 *
 * 	(c) 1986, 1987, 1988, 1989, 1990  Sun Microsystems, Inc
 * 	(c) 1983, 1984, 1985, 1986, 1987, 1988, 1989  AT&T.
 *		All rights reserved.
 *
 */

#ident	"@(#)vm_as.c	1.84	95/08/15 SMI"
/*	From:	SVr4.0	"kernel:vm/vm_as.c	1.28"		*/

/*
 * VM - address spaces.
 */

#include <sys/types.h>
#include <sys/t_lock.h>
#include <sys/param.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/mman.h>
#include <sys/sysmacros.h>
#include <sys/cpuvar.h>
#include <sys/sysinfo.h>
#include <sys/kmem.h>
#include <sys/vnode.h>
#include <sys/vmsystm.h>
#include <sys/cmn_err.h>
#include <sys/debug.h>
#include <sys/tnf_probe.h>

#include <vm/hat.h>
#include <vm/as.h>
#include <vm/seg.h>
#include <vm/seg_vn.h>
#include <vm/seg_kmem.h>
#include <vm/seg_map.h>

static struct kmem_cache *as_cache;
static struct kmem_cache *seg_skiplist_cache;

/*
 * The random number generator function is based on an algorithm
 * attributed to G. J. Mitchell and D. P. Moore (1958) and described
 * in Knuth's _The Art of Computer Programming_, Vol 2, _Seminumerical
 * Algorithms_, pages 26-29.  The seeds were generated by the random
 * number generator algorithm itself.
 */
static u_int ssl_randtab[71] = {
	0x7d334262, 0x6346d245, 0x5f28efb9, 0xc9bd5ee5, 0x8380c56f,
	0xaa24f1fb, 0x8d890834, 0x3a4b2c27, 0x4a5b0aa7, 0xed01b10e,
	0x1a33b852, 0x621a1076, 0x427c69d2, 0x28c7d209, 0xdb7ce347,
	0x0fd22580, 0x87f39089, 0x34c6455a, 0x243e1a50, 0x1de7a14e,
	0x2bb5ba0f, 0x0ad8db02, 0xe58b99d2, 0xc494c2bf, 0xc8d6518a,
	0x02fe313a, 0x1e09edab, 0x16948b04, 0xdd79f72f, 0xa8448c43,
	0x28112533, 0xf3f0a7e6, 0xc3acdcd2, 0xfd63bdcd, 0xb97554f5,
	0xc52b1f04, 0x2b9d002d, 0x1aa86589, 0x2dda4fb4, 0x3977d995,
	0xf1b5ce9f, 0x4c5b5a8d, 0x6d5d6e8c, 0x2279442a, 0x54915c49,
	0xd8f5e556, 0x7e191817, 0xcf11c7e4, 0x7f0e7b14, 0x5caffa77,
	0xe7d34976, 0xbdef82ed, 0xf29d3869, 0x80746a85, 0x872f279a,
	0xf0c927f9, 0x737803f3, 0x3cd10937, 0x98971885, 0xe95a05cc,
	0xc9650e2a, 0x7cb4411f, 0xa4991d38, 0x37b0c27c, 0xd9b22936,
	0xb105b2a8, 0x7eca15fe, 0x325b821a, 0x8676f996, 0x83845ab8,
	0xf5c4b310
};

static u_int *ssl_n1p = &ssl_randtab[0];
static u_int *ssl_n2p = &ssl_randtab[35];
extern kmutex_t ssl_randlock;	/* serialize ssl_random */

static u_int
ssl_random() {
	u_int r;

	mutex_enter(&ssl_randlock);
	*ssl_n1p++ += *ssl_n2p++;
	if (ssl_n1p >= &ssl_randtab[71])
		ssl_n1p = &ssl_randtab[0];
	if (ssl_n2p >= &ssl_randtab[71])
		ssl_n2p = &ssl_randtab[0];
	r = *ssl_n1p;
	mutex_exit(&ssl_randlock);
	return (r);
}

/*
 * skiplist level generator.  The probability of the new level being
 *	 > 0 is 1/SSL_BFACTOR,
 *	 > 1 is 1/SSL_BFACTOR**2,
 *	 > 2 is 1/SSL_BFACTOR**3, and so on.
 */
static u_int
ssl_newlevel() {
	u_int newlev = 1;
	u_int r = ssl_random();

	while ((r & (SSL_BFACTOR - 1)) == 0 && newlev < SSL_NLEVELS) {
		r >>= SSL_LOG2BF;
		newlev++;
	}

	return (newlev - 1);
}

/*
 * Search a segment skiplist for addr. If a segment containing addr
 * exists, that segment is returned.  If no such segment exists, and
 * the list spans addresses greater than addr, then the first segment
 * whose base is greater than addr is returned.
 *
 * If the list does not span addresses greater than addr, and tail is
 * true, return the last element in the list.  Otherwise, return NULL.
 *
 * as->a_cache.spath points to the path recorded by a previous search
 * in this skiplist.  This information is needed for inserting and
 * deleting elements in the skiplist, and it is used as a cache for
 * the search.  If the segment to which the zeroth pointer in spath
 * refers is the one we seek, then we simply return it.  If the next
 * segment in the list is the one we seek, then we patch up the lower
 * values of spath and return it.  Otherwise, we search from the head
 * of the list, recording the search path in spath as we go.
 *
 * For a general description of skip lists, see "Skip Lists: A
 * Probabilistic Alternative to Balanced Trees" by William Pugh,
 * published in CACM Vol.33 No.6, June 1990
 */
static struct seg *
ssl_search(as, addr, tail)
	struct as *as;
	caddr_t addr;
	int tail;
{
	int i, hilev;
	struct seg *seg;
	seg_skiplist *ssl, *cssl;
	ssl_spath spath;

	ASSERT(AS_READ_HELD(as, &as->a_lock) || AS_WRITE_HELD(as, &as->a_lock));

	mutex_enter(&as->a_contents);
	spath = *as->a_cache.spath;
	mutex_exit(&as->a_contents);
	cssl = spath.ssls[0];
	if (cssl != NULL && (seg = cssl->segs[0]) != NULL) {
		/* Are we looking for the encached segment? */
		struct seg *prev = seg->s_prev;
		if ((addr < seg->s_base + seg->s_size) &&
		    ((prev == NULL) || (addr >= prev->s_base + prev->s_size)))
			return (seg);

		/*
		 * ...Or are we looking for the immediate successor
		 * to the encached segment? (a common case)
		 */
		prev = seg;
		if ((seg = seg->s_next.skiplist->segs[0]) != NULL) {
			if ((addr >= prev->s_base + prev->s_size) &&
			    (addr < seg->s_base + seg->s_size)) {
				/* spath needs updating */
				ssl = prev->s_next.skiplist;
				for (i = 0;
				    i < SSL_NLEVELS &&
				    ssl->segs[i] != SSL_UNUSED;
				    i++)
					spath.ssls[i] = ssl;
				mutex_enter(&as->a_contents);
				*as->a_cache.spath = spath;
				mutex_exit(&as->a_contents);
				return (seg);
			}
		}
	}

	/* Cache didn't help; start search at head of skiplist */
	ssl = as->a_segs.skiplist;
	hilev = as->a_hilevel;
	for (i = hilev; i >= 0; i--) {
		seg = ssl->segs[i];
		while ((seg != NULL) && (seg->s_base + seg->s_size <= addr)) {
			ssl = seg->s_next.skiplist;
			seg = ssl->segs[i];
		}
		spath.ssls[i] = ssl;
	}

	mutex_enter(&as->a_contents);
	*as->a_cache.spath = spath;
	mutex_exit(&as->a_contents);

	if (tail && seg == NULL)
		return (as->a_tail);
	else
		return (seg);
}

/*
 * Verifying the segment lists is very time-consuming; it may not be
 * desirable always to define VERIFY_SEGLIST when DEBUG is set.
 */
#ifdef DEBUG
#define	VERIFY_SEGLIST
int do_as_verify = 0;
int do_ssl_verify = 0;
#endif

#ifdef VERIFY_SEGLIST
/*
 * verify that the skiplist is coherent.
 */
static void
ssl_verify(as)
	struct as *as;
{
	int i;
	struct seg *seg;
	ssl_spath spath;
	u_int nsegs = 0;

	if (do_ssl_verify == 0)
		return;

	ASSERT(as->a_lrep == AS_LREP_SKIPLIST);

	spath = *as->a_cache.spath;

	for (seg = as->a_segs.skiplist->segs[0]; seg != NULL;
	    seg = seg->s_next.skiplist->segs[0]) {
		ASSERT(seg->s_as == as);

		for (i = 1; i < SSL_NLEVELS; i++)
			ASSERT(seg->s_next.skiplist->segs[i] == NULL ||
			    seg->s_next.skiplist->segs[i] == SSL_UNUSED ||
			    seg->s_next.skiplist->segs[i]->s_as == as);

		ASSERT(seg->s_prev == NULL || seg->s_prev->s_as == as);
		ASSERT(seg->s_prev == NULL ||
		    seg->s_prev->s_base < seg->s_base);
		ASSERT(seg->s_next.skiplist->segs[0] == NULL ||
		    seg->s_next.skiplist->segs[0]->s_base > seg->s_base);
		ASSERT(seg->s_next.skiplist->segs[0] != NULL ||
		    seg == as->a_tail);

		for (i = 0; i < SSL_NLEVELS; i++)
			if (spath.ssls[i] == seg->s_next.skiplist)
				spath.ssls[i] = NULL;
		nsegs++;
	}

	for (i = 0; i < SSL_NLEVELS; i++)
		ASSERT(spath.ssls[i] == NULL ||
		    spath.ssls[i] == as->a_segs.skiplist);

	ASSERT(as->a_nsegs == nsegs);
}
#endif /* VERIFY_SEGLIST */

/*
 * Insert a new element into a segment skiplist.  If a new high level
 * is selected, as->a_hilevel will be updated with the new value
 */
static int
ssl_insert(as, newseg)
	struct as *as;
	struct seg *newseg;
{
	int i, newlev, hilev;
	struct seg *seg;
	caddr_t addr, eaddr;
	ssl_spath *spath;

	ASSERT(AS_WRITE_HELD(as, &as->a_lock));

	addr = newseg->s_base;
	eaddr = addr + newseg->s_size;

again:
	seg = ssl_search(as, addr, 1);

	if (seg == NULL) {
		ASSERT(as->a_segs.skiplist->segs[0] == NULL &&
		    as->a_tail == NULL);
		as->a_tail = newseg;
		newseg->s_prev = NULL;
	} else {
		caddr_t base = seg->s_base;

		/*
		 * If top of seg is below the requested address, then
		 * the insertion point is at the end of the skiplist,
		 * and seg points to the tail of the list.  Otherwise,
		 * the insertion point is immediately before seg.
		 */
		if (base + seg->s_size <= addr) {
			newseg->s_prev = seg;
			as->a_tail = newseg;
		} else {
			if (addr >= base || eaddr > base) {
#ifdef __sparcv9
				extern struct seg_ops segnf_ops;

				/*
				 * no-fault segs must disappear
				 * if overlaid.
				 * XXX need new segment type so
				 * we don't have to check s_ops
				 */
				if (seg->s_ops == &segnf_ops) {
					seg_unmap(seg);
					goto again;
				}
#endif
				return (-1);	/* overlapping segment */
			}
			newseg->s_prev = seg->s_prev;
			seg->s_prev = newseg;
		}
	}

	spath = as->a_cache.spath;
	newlev = ssl_newlevel();
	hilev = as->a_hilevel;
	if (newlev > hilev) {
		for (i = hilev + 1; i <= newlev; i++)
			spath->ssls[i] = as->a_segs.skiplist;
		as->a_hilevel = newlev;
	}

	newseg->s_next.skiplist = kmem_cache_alloc(seg_skiplist_cache,
		KM_SLEEP);

	for (i = 0; i <= newlev; i++) {
		newseg->s_next.skiplist->segs[i] = spath->ssls[i]->segs[i];
		spath->ssls[i]->segs[i] = newseg;
	}

	for (i = newlev+1; i < SSL_NLEVELS; i++)	/* never deref these */
		newseg->s_next.skiplist->segs[i] = SSL_UNUSED;

	as->a_nsegs++;

#ifdef VERIFY_SEGLIST
	ssl_verify(as);
#endif
	return (0);
}

/*
 * remove the element containing addr from the skiplist, and return a
 * pointer to that element.
 */
static struct seg *
ssl_remove(as, addr)
	struct as *as;
	caddr_t addr;
{
	int i, hilev;
	struct seg *seg;
	ssl_spath *spath;

	ASSERT(AS_WRITE_HELD(as, &as->a_lock));

	seg = ssl_search(as, addr, 0);

	if (seg == NULL || seg->s_base != addr)
		return (NULL);

	spath = as->a_cache.spath;
	hilev = as->a_hilevel;
	for (i = 0; i <= hilev; i++) {
		if (spath->ssls[i]->segs[i] != seg)
			break;

		spath->ssls[i]->segs[i] = seg->s_next.skiplist->segs[i];
	}

	if (seg->s_next.skiplist->segs[0] == NULL)
		as->a_tail = seg->s_prev;
	else
		seg->s_next.skiplist->segs[0]->s_prev = seg->s_prev;

	while (hilev > 0 && as->a_segs.skiplist->segs[hilev] == NULL)
		hilev--;
	as->a_hilevel = hilev;

	kmem_cache_free(seg_skiplist_cache, seg->s_next.skiplist);
	seg->s_next.skiplist = NULL;

	as->a_nsegs--;

#ifdef VERIFY_SEGLIST
	ssl_verify(as);
#endif
	return (seg);
}

/*
 * change the simple linked list of segments into a skiplist
 */
static void
as_mutate_seglist(struct as *as)
{
	struct seg *car, *cdr;
#ifdef DEBUG
	u_int nsegs = as->a_nsegs;
#endif

	cdr = as->a_tail;
	as->a_tail = NULL;

	/*
	 * seg_skiplist and ssl_spath are always the same size,
	 * so both can be allocated from seg_skiplist_cache.
	 */
	as->a_segs.skiplist = kmem_cache_alloc(seg_skiplist_cache, KM_SLEEP);
	struct_zero((caddr_t)as->a_segs.skiplist, sizeof (seg_skiplist));

	as->a_cache.spath = kmem_cache_alloc(seg_skiplist_cache, KM_SLEEP);
	struct_zero((caddr_t)as->a_cache.spath, sizeof (seg_skiplist));

	as->a_lrep = AS_LREP_SKIPLIST;
	as->a_nsegs = 0;

	/*
	 * Do the insertions from the top down, to take greatest
	 * advantage of the search path caching.
	 */
	while (cdr != NULL) {
		car = cdr;
		cdr = cdr->s_prev;
		ssl_insert(as, car);
	}
#ifdef DEBUG
	/* make sure that we still have all the segments we started with */
	ASSERT(as->a_nsegs == nsegs);
#endif
}

/*
 * Search a segment linked list for addr. If a segment containing addr
 * exists, that segment is returned.  If no such segment exists, and
 * the list spans addresses greater than addr, then the first segment
 * whose base is greater than addr is returned; otherwise, NULL is
 * returned unless tail is true, in which case the last element of the
 * list is returned.
 */
struct seg *
as_findseg(as, addr, tail)
	struct as *as;
	caddr_t addr;
	int tail;
{
	register struct seg *seg;
	register caddr_t base;
	int forward;

	ASSERT(AS_LOCK_HELD(as, &as->a_lock));

	/* if the list has mutated into a skiplist, pass the buck */
	if (as->a_lrep == AS_LREP_SKIPLIST)
		return (ssl_search(as, addr, tail));

	if (as->a_segs.list == NULL)	/* address space has no segments */
		return (NULL);

	/* figure out the optimal place and direction to start searching */

	seg = as->a_cache.seglast;
	if (seg == NULL)
		seg = as->a_segs.list;

	forward = 0;
	if ((base = seg->s_base) <= addr) {
		caddr_t lastaddr;
		struct seg *hiseg;
		if (addr < (base + seg->s_size))
			return (seg);	/* seglast contained addr */

		hiseg = as->a_tail;	/* highest segment */
		if ((lastaddr = hiseg->s_base + hiseg->s_size) <= addr)
			return (tail? hiseg : NULL); /* addr is out of range */

		/* address is between seg and hiseg.  Which is closer? */
		if ((addr - base) > (lastaddr - addr)) {
			seg = hiseg;    /* start reverse search at tail */
		} else {
			seg = seg->s_next.list;
			forward++;	/* start forward search after seglast */
		}
	} else {
		struct seg *loseg = as->a_segs.list;	/* lowest segment */
		if (loseg->s_base > addr)
			return (loseg);	/* lowest seg is higher than addr */

		/* address is between seg and loseg.  Which is closer? */
		if ((addr - loseg->s_base) < (base - addr)) {
			seg = loseg;
			forward++;	/* start forward search at head */
		}
		/* otherwise, start reverse search at seglast */
	}

	if (forward) {
		while (seg->s_base + seg->s_size <= addr)
			seg = seg->s_next.list;
		if (seg->s_base <= addr)	/* addr is in seg */
			as->a_cache.seglast = seg;
		return (seg);
	} else {
		struct seg *prev;
		while (seg->s_base > addr) {
			prev = seg;
			seg = seg->s_prev;
			/*
			 * We know that the reverse search won't run
			 * off the beginning of the list, because of
			 * the check for (loseg->s_base > addr) above.
			 */
			ASSERT(seg != NULL);
		}
		if (seg->s_base + seg->s_size > addr) {
			as->a_cache.seglast = seg;
			return (seg);		/* addr is in seg */
		} else {
			return (prev);		/* addr is in no seg */
		}
	}
	/*NOTREACHED*/
}

#ifdef VERIFY_SEGLIST
/*
 * verify that the linked list is coherent
 */
static void
as_verify(as)
struct as *as;
{
	struct seg *seg, *seglast;
	u_int nsegs = 0;

	if (do_as_verify == 0)
		return;

	ASSERT(as->a_lrep == AS_LREP_LINKEDLIST);

	seglast = as->a_cache.seglast;

	for (seg = as->a_segs.list; seg != NULL; seg = seg->s_next.list) {
		ASSERT(seg->s_as == as);
		ASSERT(seg->s_prev == NULL || seg->s_prev->s_as == as);
		ASSERT(seg->s_prev == NULL ||
		    seg->s_prev->s_base < seg->s_base);
		ASSERT(seg->s_next.list == NULL ||
		    seg->s_next.list->s_base > seg->s_base);
		ASSERT(seg->s_next.list != NULL || seg == as->a_tail);
		if (seg == seglast)
			seglast = NULL;
		nsegs++;
	}
	ASSERT(seglast == NULL);
	ASSERT(as->a_nsegs == nsegs);
}
#endif /* VERIFY_SEGLIST */

int as_mutation_thresh = AS_MUTATION_THRESH;

/*
 * Add a new segment to the address space
 */
int
as_addseg(as, newseg)
	register struct as *as;
	register struct seg *newseg;
{
	struct seg *seg;
	caddr_t addr, eaddr;

	ASSERT(AS_WRITE_HELD(as, &as->a_lock));

	if (as->a_nsegs >= as_mutation_thresh &&
	    as->a_lrep != AS_LREP_SKIPLIST && as != &kas)
		as_mutate_seglist(as);

	/* if the list has mutated into a skiplist, pass the buck */
	if (as->a_lrep == AS_LREP_SKIPLIST)
		return (ssl_insert(as, newseg));

	addr = newseg->s_base;
	eaddr = addr + newseg->s_size;

again:
	seg = as_findseg(as, newseg->s_base, 1);

	if (seg == NULL) {	/* list is empty */
		as->a_segs.list = as->a_tail = newseg;
		newseg->s_next.list = newseg->s_prev = NULL;
	} else {
		caddr_t base = seg->s_base;

		/*
		 * If top of seg is below the requested address, then
		 * the insertion point is at the end of the linked list,
		 * and seg points to the tail of the list.  Otherwise,
		 * the insertion point is immediately before seg.
		 */
		if (base + seg->s_size <= addr) {
			newseg->s_prev = seg;
			newseg->s_next.list = NULL;
			seg->s_next.list = as->a_tail = newseg;
		} else {
			if (addr >= base || eaddr > base) {
#ifdef __sparcv9
				extern struct seg_ops segnf_ops;

				/*
				 * no-fault segs must disappear
				 * if overlaid.
				 * XXX need new segment type so
				 * we don't have to check s_ops
				 */
				if (seg->s_ops == &segnf_ops) {
					seg_unmap(seg);
					goto again;
				}
#endif
				return (-1);	/* overlapping segment */
			}
			newseg->s_next.list = seg;
			newseg->s_prev = seg->s_prev;
			seg->s_prev = newseg;
			if (as->a_segs.list == seg)
				/* newseg is at front */
				as->a_segs.list = newseg;
			else
				newseg->s_prev->s_next.list = newseg;
		}
	}
	as->a_cache.seglast = newseg;
	as->a_nsegs++;

#ifdef VERIFY_SEGLIST
	as_verify(as);
#endif
	return (0);
}

struct seg *
as_removeseg(as, addr)
	struct as *as;
	caddr_t addr;
{
	struct seg *seg;

	ASSERT(AS_WRITE_HELD(as, &as->a_lock));

	/* if the list has mutated into a skiplist, pass the buck */
	if (as->a_lrep == AS_LREP_SKIPLIST)
		return (ssl_remove(as, addr));

	seg = as_findseg(as, addr, 0);

	if (seg == NULL || seg->s_base != addr)
		return (NULL);

	as->a_cache.seglast = seg->s_next.list;

	if (seg == as->a_tail)
		as->a_tail = seg->s_prev;
	else
		seg->s_next.list->s_prev = seg->s_prev;

	if (seg == as->a_segs.list)
		as->a_segs.list = seg->s_next.list;
	else
		seg->s_prev->s_next.list = seg->s_next.list;

	as->a_nsegs--;
#ifdef VERIFY_SEGLIST
	as_verify(as);
#endif
	return (seg);
}

/*
 * Find a segment containing addr.
 */
struct seg *
as_segat(as, addr)
	register struct as *as;
	register caddr_t addr;
{
	register struct seg *seg, *sseg;
	register struct seg *start_seg;
	caddr_t base;
	register forward;

	ASSERT(AS_LOCK_HELD(as, &as->a_lock));

	seg = as_findseg(as, addr, 0);

	if ((seg != NULL) && ((base = seg->s_base) <= addr) &&
	    (addr < base + seg->s_size))
		return (seg);
	else
		return (NULL);
}

/*
 * Serialize all searches for holes in an address space to
 * prevent two or more threads from allocating the same virtual
 * address range.  The address space must not be "read/write"
 * locked by the caller since we may block.
 */
void
as_rangelock(as)
	register struct as *as;
{
	mutex_enter(&as->a_contents);
	while (as->a_claimgap)
		cv_wait(&as->a_cv, &as->a_contents);
	as->a_claimgap = 1;
	mutex_exit(&as->a_contents);
}

/*
 * Release hold on "claimgap" and signal any other blocked threads.
 */
void
as_rangeunlock(as)
	register struct as *as;
{
	mutex_enter(&as->a_contents);
	as->a_claimgap = 0;
	cv_signal(&as->a_cv);
	mutex_exit(&as->a_contents);
}

/*
 * Wait for virtual addresses to become available in the specified
 * address space.  "a_claimgap" must be held by the caller and it is
 * re-acquired before returning to the caller.
 */
void
as_rangewait(as, cvp)
	struct as *as;
	kcondvar_t *cvp;
{
	ASSERT(as->a_claimgap);

	mutex_enter(&as->a_contents);
	as->a_claimgap = 0;
	cv_broadcast(&as->a_cv);
	cv_wait(cvp, &as->a_contents);
	while (as->a_claimgap)
		cv_wait(&as->a_cv, &as->a_contents);
	as->a_claimgap = 1;
	mutex_exit(&as->a_contents);
}

/*
 * Wakeup all waiting threads.
 */
void
as_rangebroadcast(as, cvp)
	struct as *as;
	kcondvar_t *cvp;
{
	mutex_enter(&as->a_contents);
	cv_broadcast(cvp);
	mutex_exit(&as->a_contents);
}

static void
as_constructor(void *buf, size_t size)
{
	struct as *as = buf;

	mutex_init(&as->a_contents, "as contents lock", MUTEX_DEFAULT, NULL);
	cv_init(&as->a_cv, "as cv", CV_DEFAULT, NULL);
	rw_init(&as->a_lock, "as rwlock", RW_DEFAULT, NULL);
}

static void
as_destructor(void *buf, size_t size)
{
	struct as *as = buf;

	mutex_destroy(&as->a_contents);
	cv_destroy(&as->a_cv);
	rw_destroy(&as->a_lock);
}

void
as_init(void)
{
	as_cache = kmem_cache_create("as_cache", sizeof (struct as), 0,
		as_constructor, as_destructor, NULL);
	seg_skiplist_cache = kmem_cache_create("seg_skiplist_cache",
		sizeof (seg_skiplist), 0, NULL, NULL, NULL);
}

/*
 * Allocate and initialize an address space data structure.
 * We call hat_alloc to allow any machine dependent
 * information in the hat structure to be initialized.
 */
struct as *
as_alloc(void)
{
	struct as *as;

	as = kmem_cache_alloc(as_cache, KM_SLEEP);

	as->a_paglck		= 0;
	as->a_claimgap		= 0;
	as->a_unmapwait		= 0;
	as->a_vbits		= 0;
	as->a_hat		= NULL;
	as->a_hrm		= NULL;
	as->a_rss		= 0;
	as->a_cache.seglast	= NULL;
	as->a_segs.list		= NULL;
	as->a_size		= 0;
	as->a_tail		= NULL;
	as->a_nsegs		= 0;
	as->a_lrep		= 0;
	as->a_hilevel		= 0;

	AS_LOCK_ENTER(as, &as->a_lock, RW_WRITER);
	hat_alloc(as, NULL);	/* create hat for default system mmu */
	AS_LOCK_EXIT(as, &as->a_lock);
	return (as);
}

/*
 * Free an address space data structure.
 * Need to free the hat first and then
 * all the segments on this as and finally
 * the space for the as struct itself.
 */
void
as_free(struct as *as)
{
	struct hat *hat;

	AS_LOCK_ENTER(as, &as->a_lock, RW_WRITER);
	hat_free(NULL, as);
	while (AS_SEGP(as, as->a_segs) != NULL)
		seg_unmap(AS_SEGP(as, as->a_segs));

	/*
	 * The above call to hat_free frees all the hat resources
	 * (mmu dependent resources).  Below we dispense with the hat
	 * data structure which may be used until all the segments
	 * have been unmapped above.
	 */
	hat = as->a_hat;
	hat_sub(hat, as);
	hat_freehat(hat);

	if (as->a_lrep == AS_LREP_SKIPLIST) {
		kmem_cache_free(seg_skiplist_cache, as->a_segs.skiplist);
		kmem_cache_free(seg_skiplist_cache, as->a_cache.spath);
	}

	AS_LOCK_EXIT(as, &as->a_lock);
	kmem_cache_free(as_cache, as);
}

int
as_dup(as, outas)
	register struct as *as;
	struct as **outas;
{
	register struct as *newas;
	register struct seg *seg, *newseg;
	register int error;

	AS_LOCK_ENTER(as, &as->a_lock, RW_WRITER);
	newas = as_alloc();
	AS_LOCK_ENTER(newas, &newas->a_lock, RW_WRITER);

	for (seg = AS_SEGP(as, as->a_segs); seg != NULL;
	    seg = AS_SEGP(as, seg->s_next)) {
		newseg = seg_alloc(newas, seg->s_base, seg->s_size);
		if (newseg == NULL) {
			AS_LOCK_EXIT(newas, &newas->a_lock);
			AS_LOCK_EXIT(as, &as->a_lock);
			as_free(newas);
			return (-1);
		}
		if ((error = SEGOP_DUP(seg, newseg)) != 0) {
			/*
			 * We call seg_free() on the new seg
			 * because the segment is not set up
			 * completely; i.e. it has no ops.
			 */
			AS_LOCK_EXIT(as, &as->a_lock);
			seg_free(newseg);
			AS_LOCK_EXIT(newas, &newas->a_lock);
			as_free(newas);
			return (error);
		}
		newas->a_size += seg->s_size;
	}

	error = hat_dup(as, newas);
	AS_LOCK_EXIT(newas, &newas->a_lock);
	AS_LOCK_EXIT(as, &as->a_lock);
	if (error != 0) {
		as_free(newas);
		return (error);
	}
	*outas = newas;
	return (0);
}

/*
 * Handle a ``fault'' at addr for size bytes.
 */
faultcode_t
as_fault(hat, as, addr, size, type, rw)
	struct hat *hat;
	struct as *as;
	caddr_t addr;
	u_int size;
	enum fault_type type;
	enum seg_rw rw;
{
	register struct seg *seg;
	register caddr_t raddr;			/* rounded down addr */
	register u_int rsize;			/* rounded up size */
	register u_int ssize;
	register faultcode_t res = 0;
	register caddr_t addrsav;
	struct seg *segsav;
	int as_lock_held;
	klwp_t *lwp = ttolwp(curthread);

	/*
	 * Indicate that the lwp is not to be stopped while waiting
	 * for a pagefault.  This is to avoid deadlock while debugging
	 * a process via /proc over NFS (in particular).
	 */
	if (lwp != NULL)
		lwp->lwp_nostop++;

	switch (type) {

	case F_SOFTLOCK:
		CPU_STAT_ADD_K(cpu_vminfo.softlock, 1);
		break;

	case F_PROT:
		CPU_STAT_ADD_K(cpu_vminfo.prot_fault, 1);
		break;

	case F_INVAL:
		CPU_STAT_ENTER_K();
		CPU_STAT_ADDQ(CPU, cpu_vminfo.as_fault, 1);
		if (as == &kas)
			CPU_STAT_ADDQ(CPU, cpu_vminfo.kernel_asflt, 1);
		CPU_STAT_EXIT_K();
		break;
	}

	/* Kernel probe */
	TNF_PROBE_3(address_fault, "vm pagefault", /* CSTYLED */,
		tnf_opaque,	address,	addr,
		tnf_fault_type,	fault_type,	type,
		tnf_seg_access,	access,		rw);

	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	/*
	 * XXX -- Don't grab the as lock for segkmap. We should grab it for
	 * correctness, but then we could be stuck holding this lock for
	 * a LONG time if the fault needs to be resolved on a slow
	 * filesystem, and then no-one will be able to exec new commands,
	 * as exec'ing requires the write lock on the as.
	 */
	if (as == &kas && segkmap && segkmap->s_base <= raddr &&
	    raddr + size < segkmap->s_base + segkmap->s_size) {
		seg = segkmap;
		as_lock_held = 0;
	} else {
		AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
		seg = as_segat(as, raddr);
		if (seg == NULL) {
			AS_LOCK_EXIT(as, &as->a_lock);
			if (lwp != NULL)
				lwp->lwp_nostop--;
			return (FC_NOMAP);
		}
		as_lock_held = 1;
	}

	addrsav = raddr;
	segsav = seg;

	/* LINTED lint confusion: used before set: ssize */
	for (; rsize != 0; rsize -= ssize, raddr += ssize) {
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);  /* goto next seg */
			if (seg == NULL || raddr != seg->s_base) {
				res = FC_NOMAP;
				break;
			}
		}
		if (raddr + rsize > seg->s_base + seg->s_size)
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = rsize;
		res = SEGOP_FAULT(hat, seg, raddr, ssize, type, rw);
		if (res != 0)
			break;
	}

	/*
	 * If we were SOFTLOCKing and encountered a failure,
	 * we must SOFTUNLOCK the range we already did. (Maybe we
	 * should just panic if we are SOFTLOCKing or even SOFTUNLOCKing
	 * right here...)
	 */
	if (res != 0 && type == F_SOFTLOCK) {
		for (seg = segsav; addrsav < raddr; addrsav += ssize) {
			if (addrsav >= seg->s_base + seg->s_size)
				seg = AS_SEGP(as, seg->s_next);
			ASSERT(seg != NULL);
			/*
			 * Now call the fault routine again to perform the
			 * unlock using S_OTHER instead of the rw variable
			 * since we never got a chance to touch the pages.
			 */
			if (raddr > seg->s_base + seg->s_size)
				ssize = seg->s_base + seg->s_size - addrsav;
			else
				ssize = raddr - addrsav;
			(void) SEGOP_FAULT(hat, seg, addrsav, ssize,
			    F_SOFTUNLOCK, S_OTHER);
		}
	}
	if (as_lock_held)
		AS_LOCK_EXIT(as, &as->a_lock);
	if (lwp != NULL)
		lwp->lwp_nostop--;
	return (res);
}

/*
 * Asynchronous ``fault'' at addr for size bytes.
 */
faultcode_t
as_faulta(as, addr, size)
	struct as *as;
	caddr_t addr;
	u_int size;
{
	register struct seg *seg;
	register caddr_t raddr;			/* rounded down addr */
	register u_int rsize;			/* rounded up size */
	register faultcode_t res = 0;
	klwp_t *lwp = ttolwp(curthread);

	/*
	 * Indicate that the lwp is not to be stopped while waiting
	 * for a pagefault.  This is to avoid deadlock while debugging
	 * a process via /proc over NFS (in particular).
	 */
	if (lwp != NULL)
		lwp->lwp_nostop++;

	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
	seg = as_segat(as, raddr);
	if (seg == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		if (lwp != NULL)
			lwp->lwp_nostop--;
		return (FC_NOMAP);
	}

	for (; rsize != 0; rsize -= PAGESIZE, raddr += PAGESIZE) {
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);
			if (seg == NULL || addr != seg->s_base) {
				res = FC_NOMAP;
				break;
			}
		}
		res = SEGOP_FAULTA(seg, raddr);
		if (res != 0)
			break;
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	if (lwp != NULL)
		lwp->lwp_nostop--;
	return (res);
}

/*
 * Set the virtual mapping for the interval from [addr : addr + size]
 * in address space `as' to have the specified protection.
 * It is ok for the range to cross over several segments,
 * as long as they are contiguous.
 */
int
as_setprot(as, addr, size, prot)
	struct as *as;
	caddr_t addr;
	u_int size;
	u_int prot;
{
	register struct seg *seg;
	register u_int ssize;
	register caddr_t raddr;			/* rounded down addr */
	register u_int rsize;			/* rounded up size */
	register int error = 0;

	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	if (raddr + rsize < raddr)		/* check for wraparound */
		return (ENOMEM);

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
	seg = as_segat(as, raddr);
	if (seg == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	/* LINTED lint confusion: used before set: ssize */
	for (; rsize != 0; rsize -= ssize, raddr += ssize) {
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);
			if (seg == NULL || raddr != seg->s_base) {
				error = ENOMEM;
				break;
			}
		}
		if ((raddr + rsize) > (seg->s_base + seg->s_size))
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = rsize;
		error = SEGOP_SETPROT(seg, raddr, ssize, prot);
		if (error != 0)
			break;
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (error);
}

/*
 * Check to make sure that the interval from [addr : addr + size]
 * in address space `as' has at least the specified protection.
 * It is ok for the range to cross over several segments, as long
 * as they are contiguous.
 */
int
as_checkprot(as, addr, size, prot)
	struct as *as;
	caddr_t addr;
	u_int size;
	u_int prot;
{
	register struct seg *seg;
	register u_int ssize;
	register caddr_t raddr;			/* rounded down addr */
	register u_int rsize;			/* rounded up size */
	register int error = 0;

	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	if (raddr + rsize < raddr)		/* check for wraparound */
		return (ENOMEM);

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
	seg = as_segat(as, raddr);
	if (seg == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	/* LINTED lint confusion: used before set: ssize */
	for (; rsize != 0; rsize -= ssize, raddr += ssize) {
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);
			if (seg == NULL || raddr != seg->s_base) {
				error = ENOMEM;
				break;
			}
		}
		if ((raddr + rsize) > (seg->s_base + seg->s_size))
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = rsize;

		error = SEGOP_CHECKPROT(seg, raddr, ssize, prot);
		if (error != 0)
			break;
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (error);
}

int
as_unmap(as, addr, size)
	register struct as *as;
	caddr_t addr;
	u_int size;
{
	register struct seg *seg, *seg_next;
	register caddr_t raddr, eaddr;
	register u_int ssize;
	int err;

top:
	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	eaddr = (caddr_t)(((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK);

	AS_LOCK_ENTER(as, &as->a_lock, RW_WRITER);

	/*
	 * Use as_findseg to find the first segment in the range, then
	 * step through the segments in order, following s_next.
	 */
	for (seg = as_findseg(as, raddr, 0); seg != NULL; seg = seg_next) {
		if (eaddr <= seg->s_base)
			break;		/* eaddr was in a gap; all done */

		/* this is implied by the test above */
		ASSERT(raddr < eaddr);

		if (raddr < seg->s_base)
			raddr = seg->s_base; 	/* raddr was in a gap */

		if (eaddr > (seg->s_base + seg->s_size))
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = eaddr - raddr;

		/*
		 * Save next segment pointer since seg can be
		 * destroyed during the segment unmap operation.
		 */
		seg_next = AS_SEGP(as, seg->s_next);

		err = SEGOP_UNMAP(seg, raddr, ssize);
		if (err == EAGAIN) {
			/*
			 * Segment doesn't want to be unmapped now
			 * so wait; it'll wake us up when ready.
			 */
			mutex_enter(&as->a_contents);
			AS_LOCK_EXIT(as, &as->a_lock);
			/*
			 * Anyone already asleep on this cv should
			 * be awakened because they are waiting for
			 * this condition to arise.
			 */
			if (as->a_unmapwait == 0)
				cv_broadcast(&as->a_cv);
			as->a_unmapwait = 1;
			while (as->a_unmapwait)
				cv_wait(&as->a_cv, &as->a_contents);
			mutex_exit(&as->a_contents);
			goto top;
		} else if (err) {
			AS_LOCK_EXIT(as, &as->a_lock);
			return (-1);
		}

		as->a_size -= ssize;
		raddr += ssize;
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (0);
}

int
as_map(as, addr, size, crfp, argsp)
	struct as *as;
	caddr_t addr;
	u_int size;
	int (*crfp)();
	caddr_t argsp;
{
	register struct seg *seg;
	register caddr_t raddr;			/* rounded down addr */
	register u_int rsize;			/* rounded up size */
	int error;

	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	if (raddr + rsize < raddr)		/* check for wraparound */
		return (ENOMEM);

	AS_LOCK_ENTER(as, &as->a_lock, RW_WRITER);
	if (as != &kas &&
	    as->a_size + rsize > u.u_rlimit[RLIMIT_VMEM].rlim_cur) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	seg = seg_alloc(as, addr, size);
	if (seg == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	error = (*crfp)(seg, argsp);

	/*
	 * If some error occurred during the create function, destroy
	 * this segment.  Otherwise, if the address space is locked,
	 * establish memory locks for the new segment.
	 */
	if (error != 0) {
		seg_free(seg);
		AS_LOCK_EXIT(as, &as->a_lock);
	} else {
		/*
		 * Add size now so as_unmap will work if as_ctl fails.
		 */
		as->a_size += rsize;

		mutex_enter(&as->a_contents);
		if (as->a_paglck) {
			mutex_exit(&as->a_contents);
			AS_LOCK_EXIT(as, &as->a_lock);
			error = as_ctl(as, addr, size, MC_LOCK, 0,
			    (caddr_t)NULL, (ulong *)NULL, (size_t)NULL);
			if (error != 0)
				(void) as_unmap(as, addr, size);
		} else {
			mutex_exit(&as->a_contents);
			AS_LOCK_EXIT(as, &as->a_lock);
		}
	}
	return (error);
}

/*
 * Find a hole of at least size minlen within [base, base + len].
 * If flags specifies AH_HI, the hole will have the highest possible address
 * in the range. Otherwise, it will have the lowest possible address.
 * If flags specifies AH_CONTAIN, the hole will contain the address addr.
 * If an adequate hole is found, base and len are set to reflect the part of
 * the hole that is within range, and 0 is returned. Otherwise,
 * -1 is returned.
 * XXX This routine is not correct when base+len overflows caddr_t.
 */
/* VARARGS5 */
int
as_gap(as, minlen, basep, lenp, flags, addr)
	struct as *as;
	register u_int minlen;
	caddr_t *basep;
	u_int *lenp;
	int flags;
	caddr_t addr;
{
	register caddr_t lobound = *basep;
	register caddr_t hibound = lobound + *lenp;
	register struct seg *lseg, *hseg;
	register caddr_t lo, hi;
	register int forward;
	caddr_t save_base;
	u_int save_len;

	save_base = *basep;
	save_len = *lenp;
	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
	if (AS_SEGP(as, as->a_segs) == NULL) {
		if (valid_va_range(basep, lenp, minlen, flags & AH_DIR)) {
			AS_LOCK_EXIT(as, &as->a_lock);
			return (0);
		} else {
			AS_LOCK_EXIT(as, &as->a_lock);
			*basep = save_base;
			*lenp = save_len;
			return (-1);
		}
	}

	/*
	 * Set up to iterate over all the inter-segment holes in the given
	 * direction.  lseg is NULL for the lowest-addressed hole and hseg is
	 * NULL for the highest-addressed hole.  If moving backwards, we reset
	 * sseg to denote the highest-addressed segment.
	 */
	forward = (flags & AH_DIR) == AH_LO;
	if (forward) {
		hseg = as_findseg(as, lobound, 1);
		lseg = hseg->s_prev;
	} else {
		hseg = as_findseg(as, hibound, 1);
		if (hseg->s_base + hseg->s_size < hibound) {
			lseg = hseg;
			hseg = NULL;
		} else {
			lseg = hseg->s_prev;
		}
	}

	for (;;) {
		/*
		 * Set lo and hi to the hole's boundaries.  (We should really
		 * use MAXADDR in place of hibound in the expression below,
		 * but can't express it easily; using hibound in its place is
		 * harmless.)
		 */
		lo = (lseg == NULL) ? 0 : lseg->s_base + lseg->s_size;
		hi = (hseg == NULL) ? hibound : hseg->s_base;
		/*
		 * If the iteration has moved past the interval from lobound
		 * to hibound it's pointless to continue.
		 */
		if ((forward && lo > hibound) || (!forward && hi < lobound))
			break;
		else if (lo > hibound || hi < lobound)
			goto cont;
		/*
		 * Candidate hole lies at least partially within the allowable
		 * range.  Restrict it to fall completely within that range,
		 * i.e., to [max(lo, lobound), min(hi, hibound)].
		 */
		if (lo < lobound)
			lo = lobound;
		if (hi > hibound)
			hi = hibound;
		/*
		 * Verify that the candidate hole is big enough and meets
		 * hardware constraints.
		 */
		*basep = lo;
		*lenp = hi - lo;
		if (valid_va_range(basep, lenp, minlen,
		    forward ? AH_LO : AH_HI) &&
		    ((flags & AH_CONTAIN) == 0 ||
		    (*basep <= addr && *basep + *lenp > addr))) {
			AS_LOCK_EXIT(as, &as->a_lock);
			return (0);
		}

	cont:
		/*
		 * Move to the next hole.
		 */
		if (forward) {
			lseg = hseg;
			if (lseg == NULL)
				break;
			hseg = AS_SEGP(as, hseg->s_next);
		} else {
			hseg = lseg;
			if (hseg == NULL)
				break;
			lseg = lseg->s_prev;
		}
	}
	*basep = save_base;
	*lenp = save_len;
	AS_LOCK_EXIT(as, &as->a_lock);
	return (-1);
}

/*
 * Return the next range within [base, base + len] that is backed
 * with "real memory".  Skip holes and non-seg_vn segments.
 * We're lazy and only return one segment at a time.
 */
int
as_memory(as, basep, lenp)
	struct as *as;
	caddr_t *basep;
	u_int *lenp;
{
	register struct seg *seg;
	register caddr_t addr, eaddr;
	caddr_t segend;

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);

	addr = *basep;
	eaddr = addr + *lenp;

	seg = as_findseg(as, addr, 0);

	while (seg != NULL && seg->s_ops != &segvn_ops &&
	    SEGOP_GETTYPE(seg, addr) != MAP_PRIVATE)
		seg = AS_SEGP(as, seg->s_next);

	if (seg == NULL || seg->s_ops != &segvn_ops) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (EINVAL);
	}

	segend = seg->s_base + seg->s_size;

	if ((seg->s_base <= addr) && (addr < segend)) {
		if (segend > eaddr)
			*lenp = eaddr - addr;
		else
			*lenp = segend - addr;
		AS_LOCK_EXIT(as, &as->a_lock);
		return (0);
	}

	/*
	 * Only found a close segment, see if there's
	 * a valid range we can return.
	 */
	if (seg->s_base >= eaddr) {	/* closest segment is out of range */
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	*basep = seg->s_base;
	if (segend > eaddr)
		*lenp = eaddr - seg->s_base;	/* segment contains eaddr */
	else
		*lenp = seg->s_size;	/* seg is between addr and eaddr */
	AS_LOCK_EXIT(as, &as->a_lock);
	return (0);
}

/*
 * Swap the pages associated with the address space as out to
 * secondary storage, returning the number of bytes actually
 * swapped.
 *
 * The value returned is intended to correlate well with the process's
 * memory requirements.  Its usefulness for this purpose depends on
 * how well the segment-level routines do at returning accurate
 * information.
 */
u_int
as_swapout(as)
	register struct as *as;
{
	register struct seg *seg;
	register u_int swpcnt = 0;

	/*
	 * Kernel-only processes have given up their address
	 * spaces.  Of course, we shouldn't be attempting to
	 * swap out such processes in the first place...
	 */
	if (as == NULL)
		return (0);

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);

	/*
	 * Free all mapping resources associated with the address
	 * space.  The segment-level swapout routines capitalize
	 * on this unmapping by scavanging pages that have become
	 * unmapped here.
	 */
	hat_swapout(as);

	/*
	 * Call the swapout routines of all segments in the address
	 * space to do the actual work, accumulating the amount of
	 * space reclaimed.
	 */
	for (seg = AS_SEGP(as, as->a_segs); seg != NULL;
	    seg = AS_SEGP(as, seg->s_next)) {
		register struct seg_ops *ov = seg->s_ops;

		/*
		 * We have to check to see if the seg has
		 * an ops vector because the seg may have
		 * been in the middle of being set up when
		 * the process was picked for swapout.
		 */
		if ((ov != NULL) && (ov->swapout != NULL))
			swpcnt += SEGOP_SWAPOUT(seg);
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (swpcnt);
}

/*
 * Determine whether data from the mappings in interval [addr : addr + size]
 * are in the primary memory (core) cache.
 */
int
as_incore(as, addr, size, vec, sizep)
	struct as *as;
	caddr_t addr;
	u_int size;
	char *vec;
	u_int *sizep;
{
	register struct seg *seg;
	register u_int ssize;
	register caddr_t raddr;		/* rounded down addr */
	register u_int rsize;		/* rounded up size */
	u_int isize;			/* iteration size */
	register int error = 0;		/* result, assume success */

	*sizep = 0;
	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = ((((u_int)addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	if (raddr + rsize < raddr)		/* check for wraparound */
		return (ENOMEM);

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);
	seg = as_segat(as, raddr);
	if (seg == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (-1);
	}

	/* LINTED lint confusion: used before set: ssize */
	for (; rsize != 0; rsize -= ssize, raddr += ssize) {
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);
			if (seg == NULL || raddr != seg->s_base) {
				error = -1;
				break;
			}
		}
		if ((raddr + rsize) > (seg->s_base + seg->s_size))
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = rsize;
		*sizep += isize = SEGOP_INCORE(seg, raddr, ssize, vec);
		if (isize != ssize) {
			error = -1;
			break;
		}
		vec += btoc(ssize);
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (error);
}

/*
 * Cache control operations over the interval [addr : addr + size] in
 * address space "as".
 */
int
as_ctl(as, addr, size, func, attr, arg, lock_map, pos)
	struct as *as;
	caddr_t addr;
	u_int size;
	int func;
	int attr;
	caddr_t arg;
	ulong *lock_map;
	size_t pos;
{
	register struct seg *seg;	/* working segment */
	register caddr_t raddr;		/* rounded down addr */
	register u_int rsize;		/* rounded up size */
	register u_int ssize;		/* size of seg */
	int error = 0;			/* result */

	AS_LOCK_ENTER(as, &as->a_lock, RW_READER);

	/*
	 * If these are address space lock/unlock operations, loop over
	 * all segments in the address space, as appropriate.
	 */
	if (func == MC_LOCKAS) {
		if ((int)arg & MCL_FUTURE) {
			mutex_enter(&as->a_contents);
			as->a_paglck = 1;
			mutex_exit(&as->a_contents);
		}
		if (((int)arg & MCL_CURRENT) == 0) {
			AS_LOCK_EXIT(as, &as->a_lock);
			return (0);
		}

		for (seg = AS_SEGP(as, as->a_segs); seg != NULL;
		    seg = AS_SEGP(as, seg->s_next)) {
			error = SEGOP_LOCKOP(seg, seg->s_base,
			    seg->s_size, attr, MC_LOCK, lock_map, pos);
			if (error != 0)
				break;
			pos += seg_pages(seg);
		}

		AS_LOCK_EXIT(as, &as->a_lock);
		return (error);
	} else if (func == MC_UNLOCKAS) {
		mutex_enter(&as->a_contents);
		as->a_paglck = 0;
		mutex_exit(&as->a_contents);

		for (seg = AS_SEGP(as, as->a_segs); seg != NULL;
		    seg = AS_SEGP(as, seg->s_next)) {
			error = SEGOP_LOCKOP(seg, seg->s_base,
			    seg->s_size, attr, MC_UNLOCK, NULL, 0);
			if (error != 0)
				break;
		}

		AS_LOCK_EXIT(as, &as->a_lock);
		return (error);
	}

	/*
	 * Normalize addresses and sizes.
	 */
	raddr = (caddr_t)((u_int)addr & PAGEMASK);
	rsize = (((u_int)(addr + size) + PAGEOFFSET) & PAGEMASK) - (u_int)raddr;

	if (raddr + rsize < raddr) {		/* check for wraparound */
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	/*
	 * Get initial segment.
	 */
	if ((seg = as_segat(as, raddr)) == NULL) {
		AS_LOCK_EXIT(as, &as->a_lock);
		return (ENOMEM);
	}

	/*
	 * Loop over all segments.  If a hole in the address range is
	 * discovered, then fail.  For each segment, perform the appropriate
	 * control operation.
	 */
	while (rsize != 0) {

		/*
		 * Make sure there's no hole, calculate the portion
		 * of the next segment to be operated over.
		 */
		if (raddr >= seg->s_base + seg->s_size) {
			seg = AS_SEGP(as, seg->s_next);
			if (seg == NULL || raddr != seg->s_base) {
				AS_LOCK_EXIT(as, &as->a_lock);
				return (ENOMEM);
			}
		}
		if ((raddr + rsize) > (seg->s_base + seg->s_size))
			ssize = seg->s_base + seg->s_size - raddr;
		else
			ssize = rsize;

		/*
		 * Dispatch on specific function.
		 */
		switch (func) {

		/*
		 * Synchronize cached data from mappings with backing
		 * objects.
		 */
		case MC_SYNC:
			if (error = SEGOP_SYNC(seg, raddr, ssize,
			    attr, (u_int)arg)) {
				AS_LOCK_EXIT(as, &as->a_lock);
				return (error);
			}
			break;

		/*
		 * Lock pages in memory.
		 */
		case MC_LOCK:
			if (error = SEGOP_LOCKOP(seg, raddr, ssize,
			    attr, func, lock_map, pos)) {
				AS_LOCK_EXIT(as, &as->a_lock);
				return (error);
			}
			break;

		/*
		 * Unlock mapped pages.
		 */
		case MC_UNLOCK:
			(void) SEGOP_LOCKOP(seg, raddr, ssize, attr, func,
			    (ulong *)NULL, (size_t)NULL);
			break;

		/*
		 * Store VM advise for mapped pages in segment layer.
		 */
		case MC_ADVISE:
			(void) SEGOP_ADVISE(seg, raddr, ssize, (int)arg);
			break;

		/*
		 * Can't happen.
		 */
		default:
			cmn_err(CE_PANIC, "as_ctl: bad operation %d", func);
			/* NOTREACHED */
		}

		rsize -= ssize;
		raddr += ssize;
	}
	AS_LOCK_EXIT(as, &as->a_lock);
	return (0);
}

u_int
as_getprot(as, saddr, naddr)
	struct as *as;
	caddr_t *saddr;
	caddr_t *naddr;
{
	register struct seg *seg;
	register struct segvn_data *svd;
	register caddr_t addr;
	caddr_t eaddr;
	vnode_t *vp;
	vattr_t vattr;
	u_int prot;
	u_int nprot;
	int check_noreserve;
	char incore;

	ASSERT(AS_READ_HELD(as, &as->a_lock));

	/*
	 * Get the segment.
	 */
	addr = *saddr;
	seg = as_segat(as, addr);
	ASSERT(seg != NULL);
	eaddr = seg->s_base + seg->s_size;

	/*
	 * Don't include pages in the address range that don't map
	 * to pages in the underlying mapped file, if one exists.
	 * We just have to adjust eaddr to match the size of the file.
	 */
	vattr.va_mask = AT_SIZE;
	if (SEGOP_GETVP(seg, addr, &vp) == 0 &&
	    vp != NULL && vp->v_type == VREG &&
	    VOP_GETATTR(vp, &vattr, 0, CRED()) == 0) {
		u_long size = vattr.va_size;
		u_long offset = SEGOP_GETOFFSET(seg, addr);

		if (size < offset)
			size = 0;
		else
			size -= offset;
		size = roundup(size, PAGESIZE);
		if (size < seg->s_size)
			eaddr = seg->s_base + size;

		/*
		 * If we ended up with no pages, set both return addresses to
		 * the end of the segment.  Loops in the callers expect this.
		 */
		if (addr >= eaddr) {
			eaddr = seg->s_base + seg->s_size;
			*saddr = eaddr;
			*naddr = eaddr;
			return (0);
		}
	}

	/*
	 * Don't include MAP_NORESERVE pages in the address range
	 * unless their mappings have actually materialized.
	 * We cheat by knowing that segvn is the only segment
	 * driver that supports MAP_NORESERVE.
	 */
	check_noreserve = (seg->s_ops == &segvn_ops &&
			(svd = (struct segvn_data *)seg->s_data) != NULL &&
			(svd->vp == NULL || svd->vp->v_type != VREG) &&
			(svd->flags & MAP_NORESERVE));

	if (check_noreserve) {
		do {
			/*
			 * Guilty knowledge here.  We know that
			 * segvn_incore returns more than just the
			 * low-order bit that indicates the page is
			 * actually in memory.  If any bits are set,
			 * then there is backing store for the page.
			 */
			if (SEGOP_INCORE(seg, addr, PAGESIZE, &incore)
			    != PAGESIZE || incore)
				break;
		} while ((addr += PAGESIZE) < eaddr);

		*saddr = addr;
		if (addr == eaddr) {
			*naddr = addr;
			return (0);
		}
	}
	SEGOP_GETPROT(seg, addr, 0, &prot);

	while ((addr += PAGESIZE) < eaddr) {
		SEGOP_GETPROT(seg, addr, 0, &nprot);
		if (nprot != prot)
			break;
		/*
		 * Stop on the first MAP_NORESERVE page
		 * that has no backing store.
		 */
		if (check_noreserve &&
		    SEGOP_INCORE(seg, addr, PAGESIZE, &incore) == PAGESIZE &&
		    !incore)
			break;
	}
	*naddr = addr;
	return (prot);
}

/*
 * Special code for exec to move the stack segment from its interim
 * place in the old address to the right place in the new address space.
 */
/*ARGSUSED*/
int
as_exec(oas, ostka, stksz, nas, nstka, hatflag)
	struct as *oas;
	caddr_t ostka;
	int stksz;
	struct as *nas;
	caddr_t nstka;
	u_int hatflag;
{
	struct seg *stkseg;
	register int error;

	AS_LOCK_ENTER(oas, &oas->a_lock, RW_WRITER);
	stkseg = as_removeseg(oas, ostka);
	ASSERT(stkseg != NULL);
	ASSERT(stkseg->s_base == ostka && stkseg->s_size == stksz);
	stkseg->s_as = nas;
	stkseg->s_base = nstka;

#ifdef LOCKNEST
	(void) as_addseg(nas, stkseg);
#else
	/*
	 * It's ok to lock the address space we are about to exec to.
	 */
	AS_LOCK_ENTER(nas, &nas->a_lock, RW_WRITER);
	nas->a_size += stkseg->s_size;
	oas->a_size -= stkseg->s_size;
	(void) as_addseg(nas, stkseg);
	AS_LOCK_EXIT(nas, &nas->a_lock);
#endif
	error = hat_exec(oas, ostka, stksz, nas, nstka, hatflag);
	AS_LOCK_EXIT(oas, &oas->a_lock);
	return (error);
}
